* 네트워크에서의 서버와 클라이언트

먼저 네트워크에서의 서버와 클라이언트부터 살펴보자. 서비스를 제공하는 쪽이 서버이고, 서비스를 제공받는 쪽이 클라이언트이다. 여기서는 클라이언트가 고객을 뜻하게 된다. 그렇다면 서버라는 단어에서 고성능 컴퓨터가 떠오르는 이유도 보통 하나의 서버를 통해 다수의 클라이언트가 서비스를 제공받기
때문이라고 생각할 수 있다. 물론 서비스의 특징과 규모에 따라 다르겠지만, 하나의 고성능 서버는 클라이언트를 수십 대에서 수만 대까지 수용할 수 있다.

* 로드 밸런싱

로드 밸런싱이란 부하 분산, 즉 서버에 가해지는 부하를 분산하는 것이다. 사용자들의 트래픽을 여러 서버가 나눠 받도록 구성하며, 일반적으로 네트워크 장비인 스위치를 할당해 로드 밸런싱할 수 있다. 스위치에서 어떤 서버로 로드 밸런싱이 되도록 할지는 소프트웨어적으로 제어할 수 있다.

* 캐시

트래픽 처리를 위한 또 다른 방법으로는 캐시가 있다. 캐시를 쉽게 설명하면 '비용이 큰 작업의 결과를 어딘가에 저장하여 비용이 작은 작업으로 동일한 효과를 내는 것'이라고 할 수 있다.
캐시를 이용하면 매번 요청이 들어올 때마다 비용이 큰 작업을 다시 수행할 필요 없이 미리 저장된 결과로 응답하면 된다. 물론 이렇게 하면 가장 최신의 데이터는 아닐 수 있지만, 성능을 극대화시키고자 하는 캐시의 목적을 생각해 데이터의 실시간성을 조금 포기해도 되는 경우가 많다.

* 애플리케이션에서의 서버와 클라이언트

네트워크에서의 서버와 클라이언트는 물리적인 장치 간의 관계를 뜻한다. 연결된 장치 사이에는 유의미한 트래픽이 오고간다. 네트워크로 연결된 두 장치에서는 각자의 역할에 따라 실제 유의미한 트래픽을 주고 받는 애플리케이션이 실행된다.

* 소스코드에서의 서버와 클라이언트

소스코드에도 서버와 클라이언트가 존재한다. 앞서 설명했듯이 어떤 서비스를 제공하는 것은 서버이고, 서비스를 제공받는 것은 클라이언트이다. 그럼 A라는 코드가 B라는 코드를 사용한다면 B는 서버코드가 될 것이고, A는 B코드를 사용하는 클라이언트 코드가 될 것이다.

*서버와 브라우저

우리가 일상에서 가장 자주 접하는 클라이언트는 구글 크롬과 같은 브라우저이다. 정확히 말하면 웹 서버에 접속할 수 있는 웹 브라우저로, HTTP라는 프로토콜을 통해 서로 통신한다. 이를 통해서 웹 서버와 웹 브라우저가 통신하는 원리에 대해 알아보자.

* www.google.com에 접속하면 생기는 일

컴퓨터에 웹 브라우저를 열고 구글 홈페이지(www.google.com)에 접속하면 구글 화면이 나타난다. 우리는 어떻게 이 화면을 볼 수 있는 것일까?

1. DNS 서버 조회
네트워크 상에서 클라이언트가 서버를 찾아가려면 IP 주소를 알아야 한다. 하지만 우리가 아는 것은 구글 웹 서버의 IP 주소가 아닌 'www.google.com'이라는 구글의 도메인 네임 뿐이다. 인터넷에는 이러한 도메인 네임을 IP로 변경해주는 DNS(Domain Name Service)가 있다.
DNS도 하나의 애플리케이션 서비스이다. 이렇게 클라이언트는 DNS를 통해 구글 웹 서버의 IP 주소를 얻고, 이 주소로 구글의 웹 서버를 찾아가게 된다.

2. 라우터 접속
구글 웹 서버의 IP를 가지고 출발한 클라이언트의 요청은 PC에 연결된 랜선이나 와이파이 전파를 타고 공유기를 거쳐 인터넷 구간을 지난다. 인터넷은 KT와 같은 인터넷 사업자들에 의해 관리되는 회선으로, 회선 중간마다 라우터가 존재한다. 이 라우터는 클라이언트의 요청에 적혀있는
IP 주소를 기반으로 다음 경로를 안내해준다. 일반적으로 국내에서 서비스 중인 웹 서버에 접근할 때는 3~15개 정도의 라우터를 거친다.

3. HTML 문서 전달
라우터의 안내를 받아 구글의 웹 서버에 도달한 클라이언트의 요청은 구글의 웹 서버에서 실행중인 웹 서버 애플리케이션에게 전달된다. 그럼 웹 서버 애플리케이션은 클라이언트의 요청에 해당하는 HTML 문서를 응답으로 준다. 이 HTML 문서는 왔던 길을 다시 되돌아가 최종적으로
클라이언트(웹 브라우저)에게 전달된다.

4. 웹 브라우저의 역할
웹 브라우저는 웹 서버 애플리케이션으로부터 전달받은 HTML 문서 뿐만 아니라 이미지, 동영상 파일 등의 다양한 요소를 종합하여 사용자들에게 보여주고, 우리는 모든 리소스가 포함되어 있는 완성된 웹 페이지를 보게된다. 이렇게 서버로부터 응답받은 HTML 문서를 사용자가 볼 수 있는
형태로 만드는 과정을 렌더링이라고 한다. 결과적으로 웹 브라우저가 하는 일은 다음과 같다.
    1. 사용자가 도메인 네임을 입력하면 DNS를 통해 IP 주소로 변환한다.
    2. 사용자의 액션에 따라 웹 애플리케이션 서버로 요청을 보낸다.
    3. 사용자가 보낸 요청에 대한 응답을 받아 웹 페이지 화면에 렌더링한다.

웹 브라우저는 이외에도 여러 기능을 제공하지만, 이 세가지가 웹 서핑을 가능하게 하는 핵심 기능이다.

5. 요청과 응답
앞서 구글 홈페이지에 접속하는 과정에서 요청과 응답이라는 단어가 여러번 등장했다. 요청이란 구체적으로 웹 브라우저가 웹 서버에게 HTML 문서를 달라고 요청하는 것을 말하고, 응답이란 HTTP 요청을 받은 웹 서버가 요청에 해당하는 HTML 문서를 주는 것을 말한다.
요청과 응답은 단순히 HTML 문서나 문자열만이 아니라 이미지, 동영상 파일, JSON이라는 데이터만 주고 받기도 한다. 또한 요청을 처리하는데 실패하면 에러에 해당하는 응답을 돌려주기도 한다.

* IP주소
우리는 주소를 통해 위치를 식별한다. 네트워크에서도 마찬가지이다. '142.251.42.132'와 같은 4개의 숫자 조합이 네트워크상에서의 주소인 IP주소이다. 이 IP주소가 어떻게 구성되어 있는지 알아보자.

* IP주소의 구성
IP주소는 마침표를 기준으로 구분한 4개의 숫자 조합으로 구성된다. 각 구역의 숫자는 0~255 사이의 숫자로 이루어지므로 0.0.0.0부터 255.255.255.255까지 존재할 수 있다. 따라서 이론적으로 존재 가능한 IP주소는 256의 4제곱인 약 43억개 정도가 된다.
단, 특별한 의미로 사용되는 IP들이 일부 있어 실제 사용가능한 IP 주소는 더 적다.

* 포트
여러 개의 서버 애플리케이션에 접근하려면 IP 주소만으로 충분할까? 그렇지 않다. IP 주소는 클라이언트의 요청을 물리적인 장치인 서버까지는 안내해 줄 수 있지만, 해당 서버에서 돌아가고 있는 서버 애플리케이션까지 전달해 주기에는 정보가 부족하다. 각각에 서버 애플리케이션에
정확하게 요청을 전달하기 위해서는 포트라는 추가 정보가 필요하다. 앞에서 구글 홈페이지에 접속했을 때는 'www.google.com'이라는 주소만 입력했지 직접 포트를 입력하지는 않았다. 웹 브라우저는 포트 번호를 명시적으로 적어 주지 않아도 해당 프로토콜의 기본 포트를 요청에 추가하여 준다.
우리가 요청을 보내는 프로토콜은 웹에서 요청하는 것이므로 HTTP를 사용하는데, www.google.com으로 접속하면 프로토콜을 추가해 http://google.com으로 동일하게 접속하게 된다. 또한 HTTP의 기본 포트는 80번이므로 http://www.google.com:80이라고 요청을 보내는 것과 동일하다.

* 웹 서버와 WAS
사용자의 웹 브라우저에서 시작된 요청이 구글 웹 서버에게 도달하는 과정을 살펴보았다. 여기에서 웹 서버라는 용어는 다음 세 가지 의미로 사용된다.

1. 웹 서비스가 실행되고 있는 물리적인 형태의 서버
2. 물리적인 서버 내에서 실행 중이며 웹 요청을 받을 수 있는 서버
3. 프로그래밍 언어에 의해 특정 로직이 실행되는 웹 애플리케이션 서버

1은 네트워크 장비나 데이터베이스 등 실제 존재하는 물리적인 장치를 의미한다. 2와 3이 핵심인데 보통 2를 웹 서버, 3을 애플리케이션 서버, 즉 WAS라고 한다. 둘 다 통상적으로는 웹 서버라고 부르기도 하고, 상황에 따라 명확히 구분하여 부르기도 한다. 그럼 정확히 어떤 차이가 있는 걸까?

웹 서버는 보통 정적인 콘텐츠를 제공하는 것에 중점을 둔다. 예를 들어, HTML, CSS, 자바스크립트나 이미지 파일처럼 사용자가 요청한 콘텐츠를 정적인 형태 그대로 반환해 주는 역할을 한다. 반면, WAS는 이런 정적인 콘텐츠에 더해 사용자의 요청에 따라 어떠한 로직을 실행시키거나, 그 로직의
결과에 맞춰 서버에 존재하지 않던 콘텐츠를 새로 만들어 응답하기도 한다.

이런 의문이 들 수 있다. WAS가 웹 서버가 하는 역할까지 다 할 수 있으니 굳이 웹 서버를 쓸 필요가 없지 않을까? 웹 서버는 WAS보다 범용성은 떨어지지만, 정적인 콘텐츠만을 주로 서비스하는 경우에는 WAS보다 훨씬 더 좋은 성능을 보일 수 있다.
대표적인 웹 서버로는 엔진엑스, 아파치, WAS로는 자바를 기준으로 톰캣과 언더토우 등이 많이 사용된다.

* 서버와 서버
- 서버와 서버를 연결해야 하는 이유

웹 서비스의 사용자들은 보통 웹서비스가 다음과 같이 하나의 서버에서 서비스되고 있다고 생각할 것이다.

우리가 사용하고 있는 구글 검색 서비스를 생각해 보자. 구글 웹 서버로부터 제공받은 구글 페이지에서 검색어를 입력한 후 검색 요청을 하면, 모든 검색 결과를 하나의 구글 웹 서버가 처리해 주는 것처럼 느껴진다. 하지만 하나의 서버가 처리해주는 것이 아닌 몇 가지 부가적인 서비스가 더 필요하다.

검색 서비스, 사용자 계정 관련 서비스, 검색 기록에 대한 로깅 서비스 등등 여러가지의 서비스들이 더 필요하다.

만약, 하나의 WAS에 다양한 애플리케이션을 개발해 서비스를 구성했다고 생각해보자. 이 상태에서 '계정 서비스' 개발팀에서 코드를 수정하고 해당 버전을 서버에 배포했다고 가정했을 때, 코드에 문제가 생겨 배포에 실패했고, 이전 버전으로 복구하기까지 잠시 동안 서비스가 중단되었다면

이 경우 배포에 실패한 계정 서비스 뿐만이 아닌 하나의 WAS가 제공하는 모든 서비스가 중단되었을 것이다. 이럴때는 다음과 같이 별도의 서버와 WAS에서 서비스 되도록 구성해볼수있다.

각각의 서버와 WAS에서 서비스 되도록 구성하면 같은 상황에서 한꺼번에 서비스가 중단될 일은 없다. 대신 서버와 서버간의 통신이 필요하다. 만약 사용자가 검색에 대한 로깅 작업을 요청하는 경우, 검색 서비스 쪽에서 로깅 서비스 쪽으로 바로 HTTP 요청을 할 수 있어야 한다.
